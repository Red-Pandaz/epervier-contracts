// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../src/PQRegistry.sol";
import "../src/ETHFALCON/ZKNOX_epervier.sol";

contract PQRegistryTest is Test {
    PQRegistry public registry;
    ZKNOX_epervier public epervierVerifier;
    
    // Test addresses
    address public alice = address(0x1);
    address public bob = address(0x2);
    
    // Test keys (these would normally be generated by the Python CLI)
    uint256[2] public testPublicKey = [uint256(123), uint256(456)];
    bytes32 public testPublicKeyHash;
    
    function setUp() public {
        // Deploy the verifier contract
        epervierVerifier = new ZKNOX_epervier();
        
        // Deploy the registry
        registry = new PQRegistry(address(epervierVerifier));
        
        // Calculate the public key hash
        testPublicKeyHash = keccak256(abi.encodePacked(testPublicKey[0], testPublicKey[1]));
    }
    
    function testConstructor() public {
        assertEq(address(registry.epervierVerifier()), address(epervierVerifier));
        assertEq(registry.DISABLED_PQ_KEY(), bytes32(uint256(1)));
    }
    
    function testInitialState() public {
        // Check initial nonces
        assertEq(registry.getNonce(alice), 0);
        assertEq(registry.getNonce(bob), 0);
        
        // Check no keys registered
        assertFalse(registry.hasEpervierKey(alice));
        assertFalse(registry.hasEpervierKey(bob));
        assertEq(registry.getEpervierKeyHash(alice), bytes32(0));
        assertEq(registry.getEpervierKeyHash(bob), bytes32(0));
        
        // Check PQ security not disabled
        assertFalse(registry.isPQSecurityDisabled(alice));
        assertFalse(registry.isPQSecurityDisabled(bob));
    }
    
    function testRegisterEpervierKey() public {
        // This would require actual Epervier signatures from the Python CLI
        // For now, we'll test the function signature and basic logic
        
        // Mock signature components (these would be real in actual tests)
        bytes memory salt = new bytes(40);
        uint256[] memory cs1 = new uint256[](32);
        uint256[] memory cs2 = new uint256[](32);
        uint256 hint = 123;
        
        // Mock message with ECDSA signature embedded
        bytes memory message = abi.encodePacked(
            "Register Epervier Key",
            uint256(0), // nonce
            testPublicKey[0],
            testPublicKey[1],
            new bytes(65) // mock ECDSA signature
        );
        
        // This will fail because we don't have real signatures, but it tests the function structure
        vm.expectRevert();
        registry.registerEpervierKey(salt, cs1, cs2, hint, message, testPublicKey);
    }
    
    function testChangeEpervierKey() public {
        // Test function signature and basic logic
        bytes memory oldSalt = new bytes(40);
        uint256[] memory oldCs1 = new uint256[](32);
        uint256[] memory oldCs2 = new uint256[](32);
        uint256 oldHint = 123;
        bytes memory oldMessage = abi.encodePacked("Old message", new bytes(65));
        
        bytes memory newSalt = new bytes(40);
        uint256[] memory newCs1 = new uint256[](32);
        uint256[] memory newCs2 = new uint256[](32);
        uint256 newHint = 456;
        bytes memory newMessage = abi.encodePacked(
            "Change Epervier Key",
            uint256(0),
            testPublicKey[0],
            testPublicKey[1],
            new bytes(65)
        );
        
        uint256[2] memory newPublicKey = [uint256(789), uint256(101)];
        
        vm.expectRevert();
        registry.changeEpervierKey(
            oldSalt, oldCs1, oldCs2, oldHint, oldMessage, testPublicKey,
            newSalt, newCs1, newCs2, newHint, newMessage, newPublicKey
        );
    }
    
    function testDeleteEpervierKey() public {
        bytes memory salt = new bytes(40);
        uint256[] memory cs1 = new uint256[](32);
        uint256[] memory cs2 = new uint256[](32);
        uint256 hint = 123;
        bytes memory message = abi.encodePacked(
            "Delete Epervier Key",
            uint256(0),
            new bytes(65)
        );
        
        vm.expectRevert();
        registry.deleteEpervierKey(salt, cs1, cs2, hint, message);
    }
    
    function testDisablePQSecurity() public {
        bytes memory salt = new bytes(40);
        uint256[] memory cs1 = new uint256[](32);
        uint256[] memory cs2 = new uint256[](32);
        uint256 hint = 123;
        bytes memory message = abi.encodePacked(
            "Disable PQ Security",
            uint256(0),
            new bytes(65)
        );
        
        vm.expectRevert();
        registry.disablePQSecurity(salt, cs1, cs2, hint, message);
    }
    
    function testEnablePQSecurity() public {
        bytes memory salt = new bytes(40);
        uint256[] memory cs1 = new uint256[](32);
        uint256[] memory cs2 = new uint256[](32);
        uint256 hint = 123;
        bytes memory message = abi.encodePacked(
            "Enable PQ Security",
            uint256(0),
            testPublicKey[0],
            testPublicKey[1],
            new bytes(65)
        );
        
        vm.expectRevert();
        registry.enablePQSecurity(salt, cs1, cs2, hint, message, testPublicKey);
    }
    
    function testViewFunctions() public {
        // Test all view functions work correctly
        assertEq(registry.getNonce(alice), 0);
        assertFalse(registry.hasEpervierKey(alice));
        assertEq(registry.getEpervierKeyHash(alice), bytes32(0));
        assertEq(registry.getAddressByEpervierKey(testPublicKeyHash), address(0));
        assertFalse(registry.isPQSecurityDisabled(alice));
    }
    
    function testPublicKeyHashCalculation() public {
        // Test that public key hash calculation matches
        bytes32 calculatedHash = keccak256(abi.encodePacked(testPublicKey[0], testPublicKey[1]));
        assertEq(calculatedHash, testPublicKeyHash);
    }
} 